import{_ as u,a6 as n,L as m,M as h,W as o,a7 as i,aa as l,h as s,P as r,b7 as f}from"./chunks/framework.DSr6HixA.js";const T=JSON.parse('{"title":"Module Development","description":"Learning how to develop and build custom modules for ShiroSU","frontmatter":{"layout":"doc","title":"Module Development","description":"Learning how to develop and build custom modules for ShiroSU","outline":"deep","footer":false,"breadcrumbs":[{"title":"ShiroSU","link":"/en"},{"title":"dev","link":""},{"title":"Module Development","link":"/en/dev/module"}]},"headers":[],"relativePath":"en/dev/module.md","filePath":"en/dev/module.md","lastUpdated":1755655878000}'),g={name:"en/dev/module.md"},b={class:"tip custom-block"},y={class:"footnotes"},S={class:"footnotes-list"},k={id:"fn2",class:"footnote-item"};function v(A,e,w,x,U,_){const a=n("ArticleMetadata"),d=n("NolebasePageProperties"),t=n("VPNolebaseInlineLinkPreview"),c=n("NolebaseGitContributors"),p=n("NolebaseGitChangelog");return h(),m("div",null,[e[24]||(e[24]=o("h1",{id:"module-development-guide",tabindex:"-1"},[s("Module Development Guide "),o("a",{class:"header-anchor",href:"#module-development-guide","aria-label":"Permalink to “Module Development Guide”"},"​")],-1)),i(a),i(d),e[25]||(e[25]=o("p",null,[s("For most aspects, ShiroSU is largely consistent with "),o("strong",null,[o("code",null,"Magisk"),s(" and "),o("code",null,"KernelSU")]),s(". This document only describes the differences.")],-1)),o("div",b,[e[5]||(e[5]=o("p",{class:"custom-block-title custom-block-title-default"},"TIP",-1)),e[6]||(e[6]=o("p",null,[s("If ShiroSU is only used as a module manager for other root implementations, the module standard should follow the current root implementation. ShiroSU "),o("strong",null,"will not interfere"),s(" with any behavior of other root implementations.")],-1)),o("p",null,[e[1]||(e[1]=s("However, modules' ",-1)),e[2]||(e[2]=o("strong",null,"WebUI needs to consider",-1)),e[3]||(e[3]=s(" ShiroSU's ",-1)),i(t,{href:"./webui"},{default:r(()=>e[0]||(e[0]=[s("module WebUI",-1)])),_:1,__:[0]}),e[4]||(e[4]=s(".",-1))])]),e[26]||(e[26]=l('<div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>Ensure all text files within the module use <code>UNIX (LF)</code> line endings, not <code>Windows (CR + LF)</code> or <code>Macintosh (CR)</code>!</p></div><h2 id="systemless" tabindex="-1">Systemless <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> <a class="header-anchor" href="#systemless" aria-label="Permalink to “Systemless”">​</a></h2><p>ShiroSU&#39;s Systemless is a mount mechanism similar to Magisk, with fully compatible interfaces, such as the <code>.replace</code> usage. However, ShiroSU&#39;s mount mechanism has stronger compatibility. It is based on dynamic partition identification. This means modules can directly mount partitions like <code>odm</code>, and other root implementations cannot mount, without extra effort.</p><p>Furthermore, to ensure stronger security, ShiroSU&#39;s Systemless ignores the <strong>SELinux context</strong> of mounted <strong>files/directories</strong>, <strong>directory permissions</strong>, and <strong>file/directory user/group ownership</strong>. If a file is mounted to a non-existent directory, its <strong>SELinux context</strong>, <strong>permissions</strong>, and <strong>user/group</strong> will inherit from the parent directory. Generally, these actions do not affect module operation and instead help improve stability.</p><div class="tip custom-block"><p class="custom-block-title custom-block-title-default">TIP</p><p>ShiroSU&#39;s Systemless uses the <code>systemless</code> folder within the module directory for mounting. If a module uses the <code>system</code> folder for Systemless, the <code>systemless</code> folder will be <strong>automatically created</strong>.</p><p>If a module is only compatible with ShiroSU, it can directly use the <code>systemless</code> folder for Systemless.</p></div><h2 id="shell" tabindex="-1">Shell <a class="header-anchor" href="#shell" aria-label="Permalink to “Shell”">​</a></h2><p>ShiroSU differs significantly from other root implementations here. ShiroSU&#39;s running shell scripts are <strong>not</strong> run in &quot;standalone mode&quot; within <code>BusyBox</code>.</p>',7)),o("p",null,[e[9]||(e[9]=s("To improve the convenience of shell script development, ShiroSU uses ",-1)),i(t,{href:"https://github.com/shellgei/rusty_bash",target:"_blank",rel:"noreferrer"},{default:r(()=>e[7]||(e[7]=[s("sush",-1)])),_:1,__:[7]}),e[10]||(e[10]=s(" (Bash written in Rust) to run shell scripts and prioritizes the command set of ",-1)),i(t,{href:"https://github.com/uutils/coreutils",target:"_blank",rel:"noreferrer"},{default:r(()=>e[8]||(e[8]=[s("uutils",-1)])),_:1,__:[8]}),e[11]||(e[11]=s(" (coreutils written in Rust) over Magisk's BusyBox. Commands are ",-1)),e[12]||(e[12]=o("strong",null,"first retrieved from uutils",-1)),e[13]||(e[13]=s(", and only if not found are they retrieved from BusyBox.",-1))]),e[27]||(e[27]=l(`<p>Since it&#39;s not run in &quot;standalone mode&quot; within BusyBox, commands are injected through the <code>PATH</code> environment variable. Do not hardcode modifications to <code>PATH</code> within module shell scripts!</p><h3 id="environment-variables" tabindex="-1">Environment Variables <a class="header-anchor" href="#environment-variables" aria-label="Permalink to “Environment Variables”">​</a></h3><p>To aid in differentiation, ShiroSU injects the following variables during module execution:</p><ul><li><code>SSU</code> (boolean): When running in the ShiroSU environment, this value will be <code>true</code>. However, this does not mean you can execute code with <code>$SSU &amp;&amp; # code ...</code>. Always use <code>[ &quot;$SSU&quot; = true ]</code> or a similar method to detect ShiroSU.</li><li><code>SSU_VER</code> (string): ShiroSU&#39;s version number (excluding patch number).</li><li><code>SSU_VER_CODE</code> (integer): ShiroSU&#39;s pure numerical version number (including patch number).</li></ul><h3 id="recovery" tabindex="-1">Recovery <a class="header-anchor" href="#recovery" aria-label="Permalink to “Recovery”">​</a></h3><p>ShiroSU does not support installing modules via Recovery, and code within <code>META-INF/com/google/android/update-binary</code> will not be executed during module installation.</p><h3 id="su-calls" tabindex="-1">SU Calls <a class="header-anchor" href="#su-calls" aria-label="Permalink to “SU Calls”">​</a></h3><p>ShiroSU&#39;s SU implementation defaults to a <code>sudo</code> that can only be used to directly execute shell commands, allowing direct execution of commands like <code>sudo ls /</code>.</p><p><code>sudo</code> exists only as a simple <code>su -c</code> alternative, but <strong>no</strong> module should use <code>sudo</code> or <code>su -c</code> to execute shell commands!</p><p><mark>Similarly, modules should <strong>not</strong> hardcode commands, such as <code>/data/adb/ssu/bin/busybox crond</code>, because regardless of BusyBox &quot;standalone mode&quot; or direct <code>PATH</code> injection, commands can be called directly without any hardcoded manual retrieval.</mark></p><h2 id="ansi-escape-codes" tabindex="-1">ANSI Escape Codes <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> <a class="header-anchor" href="#ansi-escape-codes" aria-label="Permalink to “ANSI Escape Codes”">​</a></h2><p>ShiroSU allows the use of <code>ANSI escape codes</code> in <code>module.prop</code> or shell scripts to enhance text display. For example, in <code>module.prop</code>:</p><div class="language-properties line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">properties</span><pre class="shiki shiki-themes github-light github-dark-dimmed" style="--shiki-light:#24292e;--shiki-dark:#adbac7;--shiki-light-bg:#fff;--shiki-dark-bg:#22272e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=ssu_cmd_ext</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=Command Set Extension</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">version</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=Auto-generated by SSU</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">versionAnsi</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=\\e[1mAuto-generated\\e[0m by SSU</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">versionCode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">author</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=SSU Developers (OOM. WG.)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">description</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=Add coreutils, busybox, and bash to /system/bin.</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">descriptionAnsi</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=Add \\e[1mcoreutils, busybox, and bash\\e[0m to \\e[1m/system/bin\\e[0m.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Using the above <code>module.prop</code>, the module will display <code>Auto-generated</code>, <code>coreutils, busybox, and bash</code>, and <code>/system/bin</code> in bold within the ShiroSU manager.</p><p>In <code>module.prop</code>, you can use <code>nameAnsi</code>, <code>versionAnsi</code>, <code>authorAnsi</code>, and <code>descriptionAnsi</code> to display text containing ANSI escape codes.</p><p>While omitting the <code>Ansi</code> suffix is possible, for compatibility, use the <code>Ansi</code> suffix.</p><p><mark>ShiroSU parses <code>module.prop</code> sequentially, so ensure values with the <code>Ansi</code> suffix are placed later in the file.</mark></p><details class="details custom-block"><summary>Expand to view rendering effect</summary><p><img src="`+f+'" alt="module.prop rendering effect"></p></details><h2 id="module-webui" tabindex="-1">Module WebUI <a class="header-anchor" href="#module-webui" aria-label="Permalink to “Module WebUI”">​</a></h2>',19)),o("p",null,[e[15]||(e[15]=s("ShiroSU, like ",-1)),e[16]||(e[16]=o("code",null,"KernelSU",-1)),e[17]||(e[17]=s(", allows modules to use WebUI for functionality, see ",-1)),i(t,{href:"./webui"},{default:r(()=>e[14]||(e[14]=[s("Module WebUI",-1)])),_:1,__:[14]}),e[18]||(e[18]=s(".",-1))]),e[28]||(e[28]=l('<h2 id="module-prop" tabindex="-1">module.prop <a class="header-anchor" href="#module-prop" aria-label="Permalink to “module.prop”">​</a></h2><p>The ShiroSU manager has a mechanism to detect if <code>module.prop</code> is corrupted or conforms to the standard. If corrupted or non-compliant, the manager will display a tag above the module.</p><div class="warning custom-block"><p class="custom-block-title custom-block-title-default">WARNING</p><p>Some modules use <code>sed</code> commands to modify <code>module.prop</code> for real-time content updates. However, this method has a high probability of corrupting the <code>module.prop</code> file. Avoid modifying <code>module.prop</code> with <code>sed</code> or other methods for real-time display. Implement a <code>module.prop</code> corruption detection mechanism to restore default content upon corruption.</p></div><p>The ShiroSU manager checks the following:</p><ul><li>Whether <code>module.prop</code> contains non-compliant syntax.</li><li>Whether <code>id</code>, <code>name</code>, <code>version</code>, <code>author</code>, <code>description</code> (and their <code>Ansi</code> counterparts) are empty.</li><li>Whether <code>id</code> matches the regular expression: <code>^[a-zA-Z][a-zA-Z0-9._-]+$</code>.</li><li>Whether <code>versionCode</code> is greater than <strong>0</strong>.</li><li>Whether <code>module.prop</code> contains case inconsistencies (the manager will parse correctly but still display a tag).</li></ul><p><mark>If only <code>module.prop</code> is corrupted, reinstalling the module usually resolves the issue. If it&#39;s non-compliant, developers must fix it.</mark></p><h2 id="kernel-interface" tabindex="-1">Kernel Interface <a class="header-anchor" href="#kernel-interface" aria-label="Permalink to “Kernel Interface”">​</a></h2><p>ShiroSU uses <code>/data/adb/ssu/._settings</code> as the kernel settings directory, typically containing the following files:</p><ul><li><code>._su_list</code>: List of packages authorized to use superuser privileges.</li><li><code>._bypass_list</code>: List of entries bypassing SELinux restrictions.</li><li><code>._hide_list</code>: List of entries needing hidden root usage traces.</li></ul><p><mark>These files store <code>binary UID</code> (32-bit integer) + <code>\\0</code> + <code>package name</code> format, with multiple values separated by <code>\\n</code>.</mark></p><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>These files are read-only. No modules/applications should modify ShiroSU&#39;s kernel configuration files. <strong>Only the ShiroSU manager</strong> has modification rights!</p><p>Modifications by other modules/applications are expected to be ineffective. ShiroSU will progressively add restrictions on kernel configuration file writing in future updates.</p></div><h2 id="other-differences" tabindex="-1">Other Differences <a class="header-anchor" href="#other-differences" aria-label="Permalink to “Other Differences”">​</a></h2><p>ShiroSU will provide <strong>module backup interface</strong>, <strong>module update interface (executing original module code during updates)</strong>, and <strong>module storage interface</strong> in future updates. These features are still under development and will be released in future updates.</p>',13)),i(c),i(p),e[29]||(e[29]=o("hr",{class:"footnotes-sep"},null,-1)),o("section",y,[o("ol",S,[e[23]||(e[23]=o("li",{id:"fn1",class:"footnote-item"},[o("p",null,[s("The Systemless mechanism is a method for modifying system files without directly modifying system partitions, providing convenience for modules. "),o("a",{href:"#fnref1",class:"footnote-backref"},"↩︎")])],-1)),o("li",k,[o("p",null,[e[20]||(e[20]=s("ANSI escape codes are a character encoding for controlling text display styles, commonly used in terminals and console applications. See ",-1)),i(t,{href:"https://en.wikipedia.org/wiki/ANSI_escape_code",target:"_blank",rel:"noreferrer"},{default:r(()=>e[19]||(e[19]=[s("Wikipedia",-1)])),_:1,__:[19]}),e[21]||(e[21]=s(". ",-1)),e[22]||(e[22]=o("a",{href:"#fnref2",class:"footnote-backref"},"↩︎",-1))])])])])])}const P=u(g,[["render",v]]);export{T as __pageData,P as default};
