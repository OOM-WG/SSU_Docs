---
layout: doc
title: モジュール開発
description: ShiroSU のカスタムモジュールを開発および構築する方法を学びます
outline: deep
footer: false
---
# モジュール開発ガイド

大部分の内容において、ShiroSU は **`Magisk` と `KernelSU`** とほぼ同じです。ここでは異なる点のみを紹介します。

::: tip

ShiroSU を他の root 実装のモジュールマネージャーとしてのみ使用する場合、モジュールの標準は現在の root 実装に準拠する必要があります。ShiroSU は他の root 実装のいかなる動作にも**干渉しません**。

ただし、モジュールの **WebUI は ShiroSU の** [モジュール WebUI](webui) を**考慮する必要があります**。

:::

> [!IMPORTANT]
> モジュール内のすべてのテキストファイルが `UNIX (LF)` 改行タイプを使用していることを確認してください。`Windows (CR + LF)` や `Macintosh (CR)` ではありません！

## Systemless [^1]

ShiroSU の Systemless は、Magisk に類似したマウントメカニズムであり、そのインターフェースは `.replace` の用法など、Magisk と完全に互換性があります。ただし、ShiroSU のマウントメカニズムは互換性が高く、動的なパーティション認識に基づいています。つまり、モジュールは `odm` など、他の root 実装ではマウントできないパーティションを直接 Systemless でマウントでき、そのために余分な労力を費やす必要はありません。

さらに、より高い安全性を確保するために、ShiroSU の Systemless は、モジュールがマウントする **ファイル/ディレクトリの SELinux コンテキスト**、**ディレクトリの権限**、および **ファイル/ディレクトリのユーザー/グループ** を無視します。ファイルが存在しないディレクトリにマウントされた場合、その **SELinux コンテキスト**、**権限**、**ユーザー/グループ** は親ディレクトリから継承されます。通常、これらの動作はモジュールの実行に影響を与えず、むしろ安定性の向上に役立ちます。

::: tip

ShiroSU の Systemless は、モジュールディレクトリ内の `systemless` フォルダを使用してマウントを実行します。モジュールが `system` フォルダを使用して Systemless を使用する場合、`systemless` フォルダは**自動的に作成されます**。

モジュールが ShiroSU のみに対応している場合、`systemless` フォルダを直接使用して Systemless を使用できます。

:::

## Shell

ShiroSU は、この点で他の root 実装とは大きく異なります。ShiroSU で実行される Shell スクリプトは、デフォルトでは `BusyBox` で "独立モード" で**実行されません**。

Shell スクリプトの開発を容易にするために、ShiroSU は [sush](https://github.com/shellgei/rusty_bash) (Rust で記述された `Bash`) を使用して Shell スクリプトを実行し、[uutils](https://github.com/uutils/coreutils) (Rust で記述された `coreutils`) のコマンドセットを優先的に使用し、Magisk の BusyBox を代替として使用します。つまり、コマンドは**最初に uutils から取得され**、存在しないコマンドのみが BusyBox から取得されます。

BusyBox で "独立モード" で実行されないため、コマンドは `PATH` 環境変数を介して注入されます。モジュールの Shell スクリプト内で `PATH` をハードコーディングして変更しないでください！

### 環境変数

区別を容易にするために、ShiroSU はモジュールの実行時に以下の変数を注入します。

- `SSU` (ブール値): ShiroSU 環境で実行されている場合、この値は `true` になります。ただし、`$SSU && # code ...` を使用してコードを実行できるわけではありません。常に `[ "$SSU" = true ]` または同様の方法を使用して ShiroSU を検出する必要があります。
- `SSU_VER` (文字列): ShiroSU のバージョン番号 (パッチ番号は含まれません)
- `SSU_VER_CODE` (整数値): ShiroSU の純粋な数値バージョン番号 (パッチ番号を含む)

### Recovery

ShiroSU は Recovery を介したモジュールのインストールをサポートしていません。モジュールのインストール時に `META-INF/com/google/android/update-binary` 内のコードは実行されません。

### SU 呼び出し

ShiroSU の SU 実装には、デフォルトで Shell コマンドを直接実行するためだけに使用できる `sudo` が付属しています。たとえば、`sudo ls /` を実行できます。

`sudo` は、簡素化された `su -c` の代替としてのみ存在しますが、モジュール内で `sudo` または `su -c` を使用して Shell コマンドを実行するべき**ではありません**！

<mark>同様に、モジュールは**ハードコーディング**によってコマンドを取得するべき**ではありません**。たとえば、`/data/adb/ssu/bin/busybox crond` などです。BusyBox の "独立モード" であっても、`PATH` を介してコマンドが直接注入されていても、コマンドはすでに直接呼び出すことができ、ハードコーディングされた手動取得は不要です。</mark>

## ANSI エスケープコード [^2]

ShiroSU では、`module.prop` または Shell スクリプトで `ANSI エスケープコード` を使用してテキストの表示を豊かにすることができます。たとえば、`module.prop` で次のコードを使用できます。

```properties {4,8}
id=ssu_cmd_ext
name=Command Set Extension
version=Auto-generated by SSU
versionAnsi=\e[1mAuto-generated\e[0m by SSU
versionCode=1
author=SSU Developers (OOM. WG.)
description=Add coreutils, busybox, and bash to /system/bin.
descriptionAnsi=Add \e[1mcoreutils, busybox, and bash\e[0m to \e[1m/system/bin\e[0m.
```

上記の `module.prop` を使用すると、モジュールが ShiroSU マネージャーに表示されるときに、`Auto-generated`、`coreutils, busybox, and bash`、および `/system/bin` が太字で表示されます。

`module.prop` では、`nameAnsi`、`versionAnsi`、`authorAnsi`、および `descriptionAnsi` を使用して、ANSI エスケープコードを含むテキストを表示できます。

`Ansi` サフィックスが含まれていなくても使用できますが、互換性を確保するために、そうしてください。

<mark>ShiroSU は `module.prop` の内容を順番に解析して読み取るため、`Ansi` サフィックスを含む値が後にあることを確認してください。</mark>

::: details 展開してレンダリング効果を表示
![module.prop 渲染效果](/assets/img/module_prop.webp)
:::

## モジュール WebUI

ShiroSU と `KernelSU` も同様に、モジュールが WebUI を使用して機能を提供することを許可しています。詳細については、[モジュール WebUI](webui) を参照してください。

## module.prop

ShiroSU マネージャーには、`module.prop` が破損しているか、仕様に準拠しているかを検出するメカニズムがあります。破損しているか、仕様に準拠していない場合、ShiroSU マネージャーはそのモジュールの上部にラベルを表示します。

::: warning

一部のモジュールでは、`sed` コマンドを使用して `module.prop` を変更し、コンテンツをリアルタイムで更新していますが、この方法では `module.prop` ファイルが破損する可能性がいくらかあります。`sed` を使用した変更を避けたり、他の方法でリアルタイムコンテンツを表示したり、`module.prop` の破損検出メカニズムを実装して、破損時にデフォルトコンテンツに復元したりすることもできます。

:::

ShiroSU マネージャーは、具体的に次の内容を検出します。

- `module.prop` 内に構文に準拠しないコンテンツが含まれているかどうか
- `id`、`name`、`version`、`author`、`description` が空かどうか ( `Ansi` サフィックスが付いている場合も同様に検出)
- `id` が次の正規表現に準拠しているかどうか: `^[a-zA-Z][a-zA-Z0-9._-]+$`
- `versionCode` が **0** より大きいかどうか
- `module.prop` 内に大文字と小文字の区別が正しくない箇所があるかどうか (ShiroSU マネージャーは正常に解析しますが、ラベルは表示されます)

<mark>`module.prop` が破損しているだけの場合は、モジュールを再インストールすることで通常この問題を解決できます。仕様に準拠していない場合は、開発者が自分で修正してこの問題を解決する必要があります。</mark>

## カーネルインターフェース

ShiroSU は `/data/adb/ssu/._settings` をカーネル設定ディレクトリとして使用します。通常、次のファイルが含まれます。

- `._su_list`: スーパーユーザー権限の使用を許可されたリスト
- `._bypass_list`: SELinux 制限をバイパスするリスト
- `._hide_list`: root 使用の痕跡を隠す必要があるリスト

<mark>上記のファイルはすべて、`バイナリ UID`(32 ビット整数) + `\0` + `パッケージ名` 形式で保存され、複数の値は `\n` で区切られます</mark>

> [!IMPORTANT]
> 上記のファイルはすべて読み取り専用です。モジュール/ソフトウェアは ShiroSU のカーネル構成ファイルを変更するべきではありません。**ShiroSU マネージャーのみ**が変更権限を持っています！
>
> 他のモジュール/ソフトウェアによる変更は無効になるはずです。ShiroSU は今後のアップデートで、カーネル構成ファイルへの書き込み制限を段階的に追加します。

## その他の違い

ShiroSU は、今後のアップデートで **モジュールバックアップインターフェース**、**モジュール更新インターフェース (更新時に元のモジュールのコードを実行)**、**モジュールストレージインターフェース** などの機能を提供する予定です。これらの内容はまだ計画段階であり、今後のアップデートでリリースされます。

[^1]: Systemless メカニズムは、システムパーティションを直接変更せずにシステムファイルを変更できる方法であり、モジュールに利便性を提供します。

[^2]: ANSI エスケープコードは、テキストの表示スタイルを制御するために使用される文字エンコード方式であり、ターミナルおよびコンソールアプリケーションでよく使用されます。詳細については、[Wikipedia](https://en.wikipedia.org/wiki/ANSI_escape_code) を参照してください。